* Installation
** MSYS2
- Download installer from https://www.msys2.org
- Start installer as local admin
- Accept default installation folder ~C:\msys64~
- Once installation is finished, before clicking ~Next~, edit
  ~c:/msys64/etc/nsswitch.conf~ (see also cywgin documentation on
  [[https://cygwin.com/cygwin-ug-net/ntsec.html][nsswitch.conf]])
  #+begin_example
    # Begin /etc/nsswitch.conf
    passwd: files db
    group: files db
    db_enum: cache builtin
    db_home: /%H # home directory is $USERPROFILE formatted as POSIX path
    db_shell: cygwin desc
    db_gecos: cygwin desc
    # End /etc/nsswitch.conf
  #+end_example
  This will ensure that the user's home directories will be their Windows
  ~$USERPROFILE~ folders
- Close the shell (it's a local admin shell)
- Start a MSYS shell as normal user with ~c:\msys64\msys2_shell.cmd~ and run
  #+begin_src shell :exports code
    pacman -Syu
  #+end_src
  Follow instructions of killing the mintty window and restart the same MSYS
  shell again and run
  #+begin_src shell :exports code
    pacman -Su
  #+end_src
- Install software
  - mingw64/mingw-w64-x86_64-libxml2 # for eww in Emacs
  - mingw64/mingw-w64-x86_64-emacs
  - msys/openssh
  - msys/winpty
  - mingw64/mingw-w64-x86_64-enchant
  - mingw64/mingw-w64-x86_64-hunspell-en
  - msys/git
  - msys/git-flow
  - msys/unzip
  - msys/zip
  - not really useful if there is no mail sync: mingw64/mingw-w64-x86_64-msmtp

  - There's a ~mingw64/mingw-w64-x86_64-graphviz~ in mingw64 but no plantuml.
    Installing plantuml from scoop would pull in graphviz from scoop too, so
    no need to install graphviz from MSYS2.
  - Do not install ~mingw64/mingw-w64-x86_64-gnupg~: its default home
    directory does not match ~$HOME/.gnupg~ and there's MSYS2's gnupg already.
- Maybe [[http://imperfect.work/2015/10/03/git-perf-tuning/][sign all executables for a speed-up]]
- Maybe edit ~c:/msys64/etc/pacman.d/mirrorlist.mingw32~,
  ~c:/msys64/etc/pacman.d/mirrorlist.mingw64~ and
  ~c:/msys64/etc/pacman.d/mirrorlist.msys~ to put an European server on the
  top of the list of mirrors (inspired by this [[https://github.com/msys2/MSYS2-packages/issues/1884][msys2-packages #1884]] issue)

** SCOOP
Some binaries will still be needed from Scoop:
- 7zip
- copyq
- dngrep
- fd
- flux
- git
- graphviz
- greenshot
- imageglass
- multicommander
- notepadplusplus
- oraclejre8
- paint.net
- pdftk
- pdf-xchange-editor
- plantuml
- ripgrep
- smallcliutils
- stretchly
- sumatrapdf
- unison
- wincompose
- winmerge

*** MultiCommander
MultiCommander's plugins are in a persisted directory, hence updated DLLs do
not automatically overwrite the existing DLLs.  To update them:
#+begin_src shell :exports code
  (cd "$SCOOP/apps/multicommander/current/Extensions.original" \
      && (tar cf - . | \
              tar xvf - --directory=../Extensions --keep-newer-files --exclude="*.xml" ))
#+end_src

* SSH & GPG setup
All sharing the same gpg-agent, incorporated in =~/.bash_profile=:
#+begin_src shell :exports code
  _gpg_tty=$(tty) && {
      # Setting GPG_TTY is recommended by GPG documentation
      export GPG_TTY=$_gpg_tty
      # Actually this isn't related to GPG, but we reuse the fact that we know
      # there's a TTY and that thus filename completion should be handled by the
      # interactive shell and thus on Windows, filename completion should be
      # case-insensitive:
      [ -n "$MSYSTEM" ] && bind "set completion-ignore-case on"
  }
  unset _gpg_tty
  # The test involving the gnupg_SSH_AUTH_SOCK_by variable is for the case where
  # the agent is started as gpg-agent --daemon /bin/sh, in which case the shell
  # inherits the SSH_AUTH_SOCK variable from the parent, gpg-agent
  #
  # echo 'enable-ssh-support:0:1' | gpgconf.exe --change-option gpg-agent
  # echo 'allow-emacs-pinentry:0:1' | gpgconf.exe --change-option gpg-agent
  #
  # See also https://opensource.com/article/19/4/gpg-subkeys-ssh or
  # https://incenp.org/notes/2015/gnupg-for-ssh-authentication.html how to use a
  # GPG key instead of separate SSH key as private key for logging in
  unset SSH_AGENT_PID
  if [ "${gnupg_SSH_AUTH_SOCK_by:-0}" -ne $$ ]; then
      # export SSH_AUTH_SOCK=$(gpg-connect-agent.exe 'getinfo ssh_socket_name' '/bye' \
      #                            | sed -n -s '/^D/s/^D //p' )
      #
      # gpgconf --list-dirs does not autostart gpg-agent.  There's
      # gpg-connect-agent /bye, but then there's little difference with above
      # except that we use a high-level command rather than manipulating output
      # with sed.
      gpg-connect-agent /bye # starts gpg-agent if needed
      export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
  fi
#+end_src

When password authentication is needed, but there is no terminal, ask the user
for password with popup dialog (also in =~/.bash_profile=):
#+begin_src shell :exports code
  # For ssh-askpass emulation: if DISPLAY & SSH_ASKPASS are set, ssh will use
  # ssh-askpass if no TTY is available to query the password:
  _ssh_askpass="$HOME/bin/ssh-askpass-with-pinentry"
  if [ -x "$_ssh_askpass" ] ; then
      # Emacs would set DISPLAY to w32 anyway, so if it is unset, set it...
      [ -z "$DISPLAY" ] && export DISPLAY="w32"
      export SSH_ASKPASS=$_ssh_askpass
      # $_ssh_askpass content: with full paths so that
      # c:\msys64\msys\bin\sh -c '$_ssh_askpass prompt text'
      # works when called from cmd.exe (without valid PATH), too
      #
      ##!/bin/sh
      #/usr/bin/cat <<EOF | /mingw64/bin/pinentry | /usr/bin/sed -n -e '/^OK/d' -e 's/^D //p'
      #SETDESC $@
      #SETPROMPT SSH Password
      #GETPIN
      #BYE
      #EOF
  fi
  unset _ssh_askpass
#+end_src

* Prompt tweaks
1. Set variable identifying the chroot you work in (used in the prompt below):
   #+begin_src shell :exports code
     if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
         debian_chroot=$(cat /etc/debian_chroot)
     fi
   #+end_src
   I only kept this for reference in case I ever work on Debian.
2. Set a fancy prompt (non-color, unless we know we "want" color)
   #+begin_src shell :exports code
     case "$TERM" in
         xterm-color|*-256color) color_prompt=yes;;
     esac

     # uncomment for a colored prompt, if the terminal has the capability; turned
     # off by default to not distract the user: the focus in a terminal window
     # should be on the output of commands, not on the prompt
     #force_color_prompt=yes

     if [ -n "$force_color_prompt" ]; then
         if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
             # We have color support; assume it's compliant with Ecma-48
             # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
             # a case would tend to support setf rather than setaf.)
             color_prompt=yes
         else
             color_prompt=
         fi
     fi

     if [ "$color_prompt" = yes ]; then
         RS="\[\033[0m\]"    # reset
         HC="\[\033[1m\]"    # hicolor
         # UL="\[\033[4m\]"    # underline
         # INV="\[\033[7m\]"   # inverse background and foreground
         # FBLK="\[\033[30m\]" # foreground black
         # FRED="\[\033[31m\]" # foreground red
         FGRN="\[\033[32m\]" # foreground green
         FYEL="\[\033[33m\]" # foreground yellow
         FBLE="\[\033[34m\]" # foreground blue
         # FMAG="\[\033[35m\]" # foreground magenta
         FCYN="\[\033[36m\]" # foreground cyan
         # FWHT="\[\033[37m\]" # foreground white
         # BBLK="\[\033[40m\]" # background black
         # BRED="\[\033[41m\]" # background red
         # BGRN="\[\033[42m\]" # background green
         # BYEL="\[\033[43m\]" # background yellow
         # BBLE="\[\033[44m\]" # background blue
         # BMAG="\[\033[45m\]" # background magenta
         # BCYN="\[\033[46m\]" # background cyan
         # BWHT="\[\033[47m\]" # background white
         # cyan is 6 (man terminfo)
         # $(tput setaf 6)
     else
         RS=""   # reset
         HC=""   # hicolor
         FGRN="" # foreground green
         FYEL="" # foreground yellow
         FBLE="" # foreground blue
         FCYN="" # foreground cyan
     fi
     unset color_prompt force_color_prompt
   #+end_src
3. Basic prompt (color is set/hidden by having the variables ~RS~, ~FGRN~ etc
   being blank strings for monochrome)
   #+begin_src shell :exports code
     PS1='${debian_chroot:+($debian_chroot)}'"${RS}${FGRN}"'\u@\h'"${RS}:${HC}${FBLE}"'\w'"${RS}"
   #+end_src
4. Enable jumping from prompt to prompt with Shift-{Left,Right} in [[https://github.com/mintty/mintty/wiki/CtrlSeqs#scroll-markers][mintty]]
   #+begin_src shell :exports code
     if [ "$MSYSCON" == "mintty.exe" ] ; then
         PS1="\[\033[?7711h\]$PS1"
     fi
   #+end_src
5. Show the git branch on the command line, adapted from Git-for-Windows
   #+begin_src shell :exports code
     function parse_git_branch () {
      git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
     }
     PS1="$PS1 $FCYN\$(parse_git_branch)$RS\$ "
   #+end_src
6. If this is an xterm set the title to user@host:dir and optional
   MSYS/MINGW64 indication
   #+begin_src shell :exports code
     case "$TERM" in
     xterm*|rxvt*)
         PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w${MSYSTEM:+ $MSYSTEM}\a\]$PS1"
         ;;
     ,*)
         ;;
     esac
   #+end_src

* Font
** Input font
** [[https://github.com/be5invis/Iosevka/][Iosevka]]
1. Download ttc-iosevka-x.x.x.zip from [[https://github.com/be5invis/Iosevka/releases/tag/v2.3.3][releases]]
2. Unzip to ~/tmp~: ~unzip ~/Downloads/ttc-iosevka-2.3.3.zip -d /tmp~
3. ~for x in /tmp/iosevka-{italic,regular,bold,bolditalic}.ttc ; do start $x ; done~
* Info documentation browser
Add this to your profile:
#+begin_src shell :exports code
  # If the Emacs info node is missing, maybe that install-info was not called.
  #
  # for f in /mingw64/share/info/*.info /mingw64/share/info/*.info.gz ; do
  #     install-info --info-dir=/mingw64/share/info/ --debug $f
  # done
  emacs_prefix="/mingw64" # or "$(dirname "$(dirname "$(type -fp emacs)")")"?
  emacs_info="$emacs_prefix/share/info"
  if [ -r "$emacs_info/emacs.info" ] ; then
      case "$INFOPATH" in
          ( *$emacs_info* ) ;;
          ( * ) export INFOPATH="$INFOPATH:$emacs_info" ;;
      esac
  fi
  unset emacs_prefix emacs_info
#+end_src
* Useful aliases in =~/.bash_aliases=
For more ideas, see also [[https://github.com/fniessen/shell-leuven][shell-leuven]].

In your ~.bashrc~ or ~.bash_profile~
#+begin_src shell :exports code
  if [ -f ~/.bash_aliases ]; then
      . ~/.bash_aliases
  fi
#+end_src

** Changing directories
#+begin_src shell :exports code
  alias ..='cd ..'
  alias ...='cd ../..'
  alias ....='cd ../../..'
  alias .....='cd ../../../..'
#+end_src

Using [[https://github.com/ajeetdsouza/zoxide][zoxide]]: ~z~ is an alias for fast jumps to often used directories
#+begin_src shell :exports code
  if type -p zoxide > /dev/null ; then
      eval "$(zoxide init bash)"
      type -p fzf > /dev/null || unalias zqi
  fi
#+end_src

** Syncing directories
Because my unison is a Windows console application (installed with scoop), it
needs ~winpty~:
#+begin_src shell :exports code
  function unison ()
  {
      if [ "$1" == "zettelkasten" ] ; then
          # The unison binary on that host is still 2.48:
          unison="$HOME/opt/bin/unison-2.48.exe"
      else
          unison="$(type -fp unison)"
      fi
      if [ -z "$unison" ] ; then
          echo "unison not found" >&2
      fi
      if [ -z "$INSIDE_EMACS" ] ; then
          # Not inside shell buffer inside Emacs, assume we have a TTY and need to
          # translate it to Windows console.
          winpty="$(type -fp winpty)"
          if [ -z "$winpty" ] ; then
              "$unison" "$@"
          else
              "$winpty" "$unison" "$@"
          fi
      else
          # Inside shell buffer inside Emacs: unison manual recommends '-dumbtty'
          "$unison" -dumbtty "$@"
      fi
  }
#+end_src

** Jumping to directory of Emacs selected buffer
This probably breaks for directories with strange characters (space, double quotes etc)
#+begin_src shell :exports code
  if [ -z "$INSIDE_EMACS" ] ; then
      # having the cde alias inside Emacs shell buffers makes no sense
      if type -p emacsclient > /dev/null ; then
          # inspired by https://github.com/fniessen/shell-leuven: cd into directory that
          # currently selected window in emacs is in
          alias cde='cd "$(emacsclient -e '\''(with-current-buffer (window-buffer (selected-window))
                                                (expand-file-name default-directory))'\'' \
                           | tr -d '\''\n\r"'\'')"'
      fi
  fi
#+end_src

** Opening a dired buffer
This is actually a function, not an alias...
#+begin_src shell :exports code
  if type -p emacsclient > /dev/null ; then
      function dired ()
      {
          # dired [dirname]: open dired of (default current) directory inside Emacs
          if [ -z "$1" ]; then
              mixedDir="."
          else
              dir="$1"
              mixedDir="$(cygpath --mixed --absolute "$dir")"
          fi
          emacsclient --no-wait "$mixedDir"
          [ -z "$INSIDE_EMACS" ] && emacsclient --suppress-output --eval "(raise-frame)"
      }
      # NB: it would be nice to do complete -F _cd dired (to have CDPATH support
      # in completion, like the `cd' shell builtin does, but then our dired
      # function would need to support CDPATH as well; I don't use CDPATH at the
      # moment, so maybe it's not that useful...)
      complete -A directory dired
  fi
#+end_src

** docker
Stop docker from complaining it needs winpty:
#+begin_src shell :exports code
  function docker ()
  {
      winpty="$(type -fp winpty)"
      if [ -z "$winpty" ] ; then
          docker "$@"
      else
          "$winpty" docker "$@"
      fi
  }
#+end_src

* Useful scripts
** Emacs
*** ~ec~: an emacsclient wrapper
From this [[https://www.reddit.com/r/emacs/comments/fk7p49/piping_stdout_to_emacs/][reddit thread]]: this shorthand for emacsclient also accepts stdin as
input.

#+begin_src shell :exports code
  #!/bin/sh
  #
  # Use this instead of emacsclient: it also reads from stdin (unless called
  # from inside Emacs *shell* buffer):
  # ec file
  # ls | ec
  if [ -n "$INSIDE_EMACS" ]; then
      emacsclient -n "$@"
  elif [ -t 0 ]; then
      emacsclient -n "$@"
  else
      # stdin has data
      tmpf=$(mktemp --tmpdir emacs-edit.XXXXXXXX)
      cat > $tmpf
      trap 'rm -rf $tmpf; trap - EXIT; exit' EXIT INT HUP
      # let emacs-eval read from stdin: because it is called in a context
      # where stdin is the input (for this script actually), it will believe
      # it must look at its stdin, too):
      emacs-eval <<EOF
        (let ((dir default-directory))
          (find-file "$(cygpath --mixed --absolute "$tmpf")")
          (setq default-directory dir)
          (set-visited-file-name nil)
          (rename-buffer "*stdin*" t))
  EOF
  fi
#+end_src

*** ~emacs-eval~: evaluat elisp from the command line
Evaluates its stdin or command line arguments.
#+begin_src shell :exports code
  #!/bin/sh

  if [ -t 0 ]; then
      sexp="$*"
  else
      sexp="$(cat)"
  fi
  exec emacsclient -n -e "$sexp"
#+end_src
